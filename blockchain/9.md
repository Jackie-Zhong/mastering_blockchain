### 挖矿和共识

挖矿是增加比特币货币供应的一个过程。挖矿同时还保护着比特币系统的安全，防止欺诈交易，避免双重支付，双重支付是指多次花费同一笔比特币。矿工通过为比特币网络提供算力来获得比特币奖励的机会。

矿工验证每笔新的交易并把它们记录在区块链上。每10分钟就会有一个新的区块被挖掘出来，每个区块里包含着从上一个区块产生到目前这段时间内发生的所有交易，这些交易被依次添加到区块链中。我们把包含在区块内且被添加到区块链上的交易称为确认交易，交易经过确认之后，新的拥有者才能花费他在此交易中得到的比特币。

矿工在挖矿过程中会得到两种类型的奖励：创建新区块的新币奖励，以及区块中所含交易的交易费。为了得到这些奖励，矿工们争相完成一种基于加密哈希算法的数学难题，这些难题的答案包括在新区块中，作为矿工的工作量证明。

新比特币的生成过程被称为挖矿是因为它的奖励机制被设计为速度递减模式。矿工通过创造一个新区块得到的比特币数量大约每四年减少一半。开始时为2009年1月每个区块奖励50个比特币，然后到2012年11月减半为每个区块奖励25个比特币。之后在2016年7月再次减半为每个新区块奖励12.5个比特币。基于这个公式，比特币挖矿奖励以指数方式递减，直到2140年。届时所有的比特币20,999,999,980全部发行完毕。

每笔交易都可能包含一笔交易费，交易费是每笔交易记录的输入和输出的差额。在挖矿过程中成功挖出新区块的矿工可以得到该区块中包含的所有的交易费。

![](https://github.com/zeoio/mastering_blockchain/blob/master/blockchain/pictures/Fig801.png)

#### 去中心化共识

在不考虑相信任何人的情况下，比特币网络中的所有参与者如何达成对任意一个所有权的共识呢？所有的传统支付系统都依赖于一个中心认证机构，依靠中心机构提供的结算服务来验证并处理所有的交易。比特币没有中心机构，几乎所有的完整节点都有一份公共总帐的备份，这份总帐可以被视为认证过的记录。区块链并不是由一个中心机构创造的，它是由比特币网络中的所有节点各自独立竞争完成的。换句话说比特币网络中的所有节点，依靠着节点间的不稳定的网络连接所传输的信息，最终得出同样的结果并维护了同一个公共总帐。这一章将介绍比特币网络不依靠中心机构而达成共识的机制。

中本聪的主要发明就是这种去中心化的自发共识机制。这种自发，是指没有经过明确选举或者没有固定达成的共识的时间。换句话说，共识是数以千计的独立节点遵守了简单的规则通过异步交互自发形成的产物。所有的比特币属性，包括货币、交易、支付以及不依靠中心机构和信任的安全模型等都是这个机制的衍生物。比特币的去中心化共识由所有网络节点的4种独立过程相互作用而产生：

- 每个全节点依据综合标准对每个交易进行独立验证
- 通过完成工作量证明算法的验算，挖矿节点将交易记录独立打包进新区块，
-  每个节点独立的对新区块进行校验并组装进区块链
-  每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链

#### 交易的独立校验

我们知道了钱包软件通过收集UTXO、提供正确的解锁脚本、构造支付给接收者的输出这一系列的方式来创建交易。产生的交易随后将被发送到比特币网络临近的节点，从而使得该交易能够在整个比特币网络中传播。

然而，在交易传递到临近的节点前，每一个收到交易的比特币节点将会首先验证该交易，这将确保只有有效的交易才会在网络中传播，而无效的交易将被废弃。

每一个节点在校验每一笔交易时，都需要对照一个长长的标准列表：

- 交易的语法和数据结构必须正确
- 输入与输出列表都不能为空
- 交易的字节大小是小于MAX_BLOCK_SIZE的
- 每一个输出值，以及总量，必须在规定值的范围内
- 没有哈希等于0
- nLockTime是小于或等于INT_MAX的
- 交易的字节大小是大于或等于100的
- 交易中的签名数量应小于签名操作数量上限
- 解锁脚本只能够将数字压入栈中，并且锁定脚本必须要符合isStandard的格式
- 池中或位于主分支区块中的一个匹配交易必须是存在的
- 对于每一个输入，如果引用的输出存在于池中任何的交易，该交易将被拒绝
- 对于每一个输入，在主分支和交易池中寻找引用的输出交易。如果输出交易缺少任何一个输入，该交易将成为一个孤立的交易
- 对于每一个输入，如果引用的输出交易是一个coinbase输出，该输入必须至少获得100个确认
- 对于每一个输入，引用的输出是必须存在的，并且没有被花费
- 使用引用的输出交易获得输入值，并检查每一个输入值和总值是否在规定值的范围内
- 如果输入值的总和小于输出值的总和，交易将被中止
- 如果交易费用太低以至于无法进入一个空的区块，交易将被拒绝
- 每一个输入的解锁脚本必须依据相应输出的锁定脚本来验证

在收到交易后，，每一个节点都会在全网广播前对这些交易进行校验，并以接收时的相应顺序，为有效的新交易建立一个池（交易池）。

#### 整合交易至区块

验证交易后，比特币节点会将这些交易添加到自己的内存池中。与其他节点一样，矿工节点会收集、验证并中继新的交易。而且矿工节点会把这些交易整合到一个候选区块中。

矿工节点维护了一个区块链的本地副本，包含了自2009年比特币系统启动运行以来的全部区块。假如，矿工节点的区块链已经收集到了区块277,314，并继续监听着网络上的交易，在尝试挖掘新区块的同时，也监听着由其他节点发现的区块。当矿工节点在挖矿时，它从比特币网络收到了区块277,315。这个区块的到来标志着277,315区块竞赛的结束，与此同时也是产出区块277,316竞赛的开始。

在上一个10分钟内，当矿工节点正在寻找区块277,315的解的同时，它也在收集交易记录为下一个区块做准备。目前它已经收到了几百笔交易记录，并将它们放进了内存池。当接收并验证区块277,315后，矿工节点会检查内存池中的全部交易，并移除已经在区块277,315中出现过的交易记录，确保任何留在内存池中的交易都是未确认的，等待被记录到新区块中。

矿工节点立刻构建一个新的空区块，做为区块277,316的候选区块。称作候选区块是因为它还没有包含有效的工作量证明，不是一个有效的区块，而只有在矿工成功找到一个工作量证明解之后，这个区块才生效。

**交易块龄，矿工费和优先级**

矿工的比特币节点需要为内存池中的每笔交易分配一个优先级，并选择较高优先级的交易记录来构建候选区块。交易的优先级是由交易输入所花费的UTXO的块龄和交易输入值的大小来决定的，块龄大的交易比那些新的、输入值小的交易拥有更高的优先级。如果区块中有足够的空间，高优先级的交易将不需要矿工费。

区块中用来存储交易的前50K字节是保留给较高优先级交易的。矿工节点在填充这50K字节的时候，会优先考虑这些最高优先级的交易，不管它们是否包含了矿工费。这种机制使得高优先级交易即便是零矿工费，也可以优先被处理。矿工的挖矿节点也会选出那些包含最小矿工费的交易，并按照每千字节矿工费进行排序，优先选择矿工费高的交易来填充剩下的区块。如果区块中仍有剩余空间，挖矿节点可以选择那些不含矿工费的交易。

在区块被填满后，内存池中的剩余交易会成为下一个区块的候选交易。因为这些交易还留在内存池中，所以随着新的区块被加到链上，这些交易输入时所引用UTXO的块龄也会随着变大。由于交易的优先值取决于它交易输入的块龄，所以这个交易的优先值也就随之增长了。最后，一个零矿工费交易的优先值就有可能会满足高优先级的门槛，被免费地打包进区块。

**创币交易**

区块中的第一笔交易是笔特殊交易，称为创币交易或者coinbase交易。这个交易是由矿工节点构造并用来奖励矿工们所做的贡献。矿工节点会创建“向矿工的地址支付25.09094928个比特币”这样一个交易，把生成交易的奖励发送到自己的钱包。矿工挖出区块获得的奖励金额是coinbase奖励和区块中全部交易矿工费的总和。

与常规交易不同，创币交易没有输入，不消耗UTXO。它只包含一个被称作coinbase的输入，仅仅用来创建新的比特币。创币交易有一个输出，支付到这个矿工的比特币地址。

#### 构造区块头

为了构造区块头，挖矿节点需要填充六个字段:

| 长度  | 字段  | 描述  |
| ------------ | ------------ | ------------ |
| 4字节  | 版本  | 版本号，用来跟踪软件或协议的升级  |
| 32字节  | 前区块哈希  | 链中前一个区块的哈希值  |
| 32字节  | Merkle根  | 一个哈希值，表示这个区块中全部交易构成的merkle树的根  |
| 4字节  | 时间戳  | 以Unix纪元开始到当下秒数记录的区块生成的时刻  |
| 4字节  | 难度目标  | 该区块的工作量证明算法难度目标  |
| 4字节  | Nonce  | 一个用于工作量证明算法的计数器  |

在区块277,316被挖出的时候，区块结构中用来表示版本号的字段值为2，长度为4字节，以小端格式编码值为0x20000000。接着，挖矿节点需要填充前区块哈希，这个值为区块277,315的区块头哈希值，它是区块277316候选区块的父区块。

为了向区块头填充merkle根字段，要将全部的交易组成一个merkle树。创币交易作为区块中的首个交易，后将余下的418笔交易添至其后，这样区块中的交易一共有419笔。merkle树的根节点将全部交易数据摘要为一个32字节长度的值。

挖矿节点会继续添加一个4字节的时间戳。

接下来，挖矿节点需要填充难度目标值，为了使得该区块有效，这个字段定义了所需满足的工作量证明的难度。

最后一个字段是nonce，初始值为0。

区块头完成全部的字段填充后，挖矿就可以开始进行了。挖矿的目标是找到一个使区块头哈希值小于难度目标的nonce。挖矿节点通常需要尝试数十亿甚至数万亿个不同的nonce取值，直到找到一个满足条件的nonce值。

#### 构建区块

用最简单的术语来说，挖矿就是重复计算区块头的哈希值，不断修改该参数，直到与哈希值匹配的一个过程。哈希函数的结果无法提前得知，也没有能得到一个特定哈希值的模式。哈希函数的这个特性意味着：得到哈希值的唯一方法是不断的尝试，每次随机修改输入，直到出现适当的哈希值。

**工作量证明算法**

哈希函数的输入数据的长度是任意的，将产生一个长度固定且绝不雷同的值，可将其视为输入的数字指纹。对于特定输入，哈希的结果每次都一样，任何实现相同哈希函数的人都可以计算和验证。一个加密哈希函数的主要特征就是不同的输入几乎不可能出现相同的数字指纹。因此，相对于随机选择输入，有意地选择输入去生成一个想要的哈希值几乎是不可能的。

比特币挖矿过程使用的是SHA256哈希函数。无论输入的大小是多少，SHA256函数的输出的长度总是256bit。

矿工用一些交易构建一个候选区块。接下来，这个矿工计算这个区块头信息的哈希值，看其是否小于当前目标值。如果这个哈希值不小于目标值，矿工就会修改这个nonce然后再试一次。

#### 成功构建区块

在对区块277,316进行挖矿时，如果成功算出了一个解，就把这个结果放进区块头，就会产生一个区块哈希值：

    0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569

而这个值小于难度目标值：

    0000000000000003A30C00000000000000000000000000000000000000000000 

挖矿节点立刻将这个区块发给它的所有相邻节点。这些节点在接收并验证这个新区块后，也会继续传播此区块。当这个新区块在网络中扩散时，每个节点都会将它作为区块277,316加到自身节点的区块链副本中。当挖矿节点收到并验证了这个新区块后，它们会放弃之前对构建这个相同高度区块的计算，并立即开始计算区块链中下一个区块的工作。

#### 校验新区块

当新区块在网络中传播时，每一个节点在将它转发到其节点之前，会进行一系列的测试去验证它。这确保了只有有效的区块会在网络中传播。独立校验还确保了诚实的矿工生成的区块可以被纳入到区块链中，从而获得奖励。行为不诚实的矿工所产生的区块将被拒绝，这不但使他们失去了奖励，而且也浪费了本来可以去寻找工作量证明解的机会，因而导致其电费亏损。

当一个节点接收到一个新的区块，它将对照一个长长的标准清单对该区块进行验证，若没有通过验证，这个区块将被拒绝:

- 区块的数据结构语法上有效
- 区块头的哈希值小于目标难度
- 区块时间戳早于验证时刻未来两个小时
- 区块大小在长度限制之内
- 第一个交易是coinbase交易
- 使用检查清单验证区块内的交易并确保它们的有效性

#### 区块链的组装与选择

比特币去中心化共识机制的最后一步是将区块集合至有最大工作量证明的链中。一旦一个节点验证了一个新的区块，它将尝试将新的区块连接到到现存的区块链，将它们组装起来。

任何时候，主链都是累计了最多难度的区块链。在一般情况下，主链也是包含最多区块的那个链，除非有两个等长的链并且其中一个有更多的工作量证明。主链也会有一些分支，这些分支中的区块与主链上的区块互为兄弟区块。这些区块是有效的，但不是主链的一部分。 保留这些分支的目的是如果在未来的某个时刻它们中的一个延长了并在难度值上超过了主链，那么后续的区块就会引用它们。

当节点接收到新区块，它会尝试将这个区块插入到现有区块链中。节点会看一下这个区块的previous block hash字段，这个字段是该区块对其父区块的引用。同时，新的节点将尝试在已存在的区块链中找出这个父区块。大多数情况下，父区块是主链的顶点，这就意味着这个新的区块延长了主链。

有时候，新区块所延长的区块链并不是主链，在这种情况下，节点将新的区块添加到备用链，同时比较备用链与主链的难度。如果备用链比主链积累了更多的难度，节点将收敛于备用链，意味着节点将选择备用链作为其新的主链，而之前那个老的主链则成为了备用链。如果节点是一个矿工，它将开始构造新的区块，来延长这个更新更长的区块链。

如果节点收到了一个有效的区块，而在现有的区块链中却未找到它的父区块，那么这个区块被认为是孤块。孤块会被保存在孤块池中，直到它们的父区块被节点收到。一旦收到了父区块并且将其连接到现有区块链上，节点就会将孤块从孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。当两个区块在很短的时间间隔内被挖出来，节点有可能会以相反的顺序接收到它们，这个时候孤块现象就会出现。

选择了最大难度的区块链后，所有的节点最终在全网范围内达成共识。随着更多的工作量证明被添加到链中，链的暂时性差异最终会得到解决。挖矿节点通过挖矿来选择它们想要延长的区块链。

#### 区块链分叉
因为区块链是去中心化的数据结构，所以不同副本之间不能总是保持一致。区块有可能在不同时间到达不同节点，导致节点有不同的区块链视角。解决的办法是，每一个节点总是选择并尝试延长代表累计了最大工作量证明的区块链，也就是最长的或最大累计难度的链。节点通过将记录在每个区块中的难度加总起来，得到建立这个链所要付出的工作量证明的总量。只要所有的节点选择最长累计难度的区块链，整个比特币网络最终会收敛到一致的状态。分叉即在不同区块链间发生的临时差异，当更多的区块添加到了某个分叉中，这个问题便会迎刃而解。

在第一张图中，网络有一个统一的区块链视角，以蓝色区块为主链的“顶点”。
![](https://github.com/zeoio/mastering_blockchain/blob/master/blockchain/pictures/Fig802.png)

我们看到两个矿工几乎同时挖到了两个不同的区块。这两个区块是顶点区块——蓝色区块的子区块，可以延长这个区块链。为了便于跟踪这个分叉事件，我们设定有一个被标记为红色的、来自加拿大的区块，还有一个被标记为绿色的、来自澳大利亚的区块。
![](https://github.com/zeoio/mastering_blockchain/blob/master/blockchain/pictures/Fig803.png)

当这个两个区块传播时，一些节点首先收到“红色”区块，一些节点收到“绿色”区块。比特币网络上的节点对于区块链的顶点产生了分歧，一派以红色区块为顶点，而另一派以绿色区块为顶点。
![](https://github.com/zeoio/mastering_blockchain/blob/master/blockchain/pictures/Fig804.png)

网络中的一部分算力专注于“红色”区块为父区块，在其之上建立新的区块；另一部分算力则专注在“绿色”区块上。即便算力在这两个阵营中平均分配，也总有一个阵营抢在另一个阵营前发现工作量证明解并将其传播出去。在这个例子中我们可以打个比方，假如工作在“绿色”区块上的矿工找到了一个“粉色”区块延长了区块链(蓝色-绿色-粉色)，他们会立刻传播这个新区块，整个网络会都会认为这个区块是有效的。
![](https://github.com/zeoio/mastering_blockchain/blob/master/blockchain/pictures/Fig805.png)

所有在上一轮选择“绿色”区块为胜出者的节点会直接将这条链延长一个区块。然而，那些选择“红色”区块为胜出者的节点现在会看到两个链：“蓝色-绿色-粉色”和“蓝色-红色”。如图，这些节点会根据结果将“蓝色-绿色-粉色”这条链设置为主链，将“蓝色-红色”这条链设置为备用链。这些节点接纳了新的更长的链，被迫改变了原有对区块链的观点，这就叫做链的重新共识。因为“红”区块做为父区块已经不在最长链上，导致了他们的候选区块已经成为了“孤块”，所以现在任何原本想要在“蓝色-红色”链上延长区块链的矿工都会停下来。全网将“蓝色-绿色-粉色”这条链识别为主链，“粉色”区块为这条链的最后一个区块。全部矿工立刻将他们产生的候选区块的父区块切换为“粉色”，来延长“蓝色-绿色-粉色”这条链。
![](https://github.com/zeoio/mastering_blockchain/blob/master/blockchain/pictures/Fig806.png)
